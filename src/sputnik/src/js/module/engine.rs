use crate::errors::js::{
    JUNO_SPUTNIK_ERROR_MODULE_DECLARE, JUNO_SPUTNIK_ERROR_MODULE_EVALUATE,
    JUNO_SPUTNIK_ERROR_MODULE_EXECUTE, JUNO_SPUTNIK_ERROR_MODULE_EXECUTE_PROMISES,
};
use rquickjs::{CatchResultExt, CaughtError, Ctx, Module};

pub async fn evaluate_async_module<'js>(
    ctx: &Ctx<'js>,
    name: &str,
    source: &str,
) -> Result<(), String> {
    let promises = Module::evaluate(ctx.clone(), name, source)
        // Without catch "Exception generated by QuickJS" stub error
        // Source: https://github.com/DelSkayn/rquickjs/issues/274#issuecomment-1979043338
        .catch(ctx) // Catch any JS exceptions here
        .map_err(|e: CaughtError| format!("{} ({:?})", JUNO_SPUTNIK_ERROR_MODULE_EVALUATE, e))?;

    promises
        .into_future::<()>()
        .await
        .catch(ctx)
        .map_err(|e| format!("{} ({})", JUNO_SPUTNIK_ERROR_MODULE_EXECUTE_PROMISES, e))
}

pub fn evaluate_module<'js>(ctx: &Ctx<'js>, name: &str, source: &str) -> Result<(), String> {
    let result =
        Module::evaluate(ctx.clone(), name, source).and_then(|module| module.finish::<()>());

    result
        .catch(ctx)
        .map_err(|e| format!("{} ({})", JUNO_SPUTNIK_ERROR_MODULE_EXECUTE, e))
}

pub fn declare_module<'js>(
    ctx: &Ctx<'js>,
    name: &str,
    source: &str,
) -> Result<Module<'js>, String> {
    Module::declare(ctx.clone(), name, source)
        .map_err(|e| format!("{} ({})", JUNO_SPUTNIK_ERROR_MODULE_DECLARE, e))
}
